from default_parameters import ML_DSA_44, ML_DSA_65, ML_DSA_87
import os
import hashlib
import numpy as np

ML_DSA = ML_DSA_65

q_minus_bit_len = (ML_DSA["q"]-1).bit_length()
t1_coff_square = q_minus_bit_len - ML_DSA["d"]
t1_coff_max = (2**t1_coff_square) - 1

# 算法 1 ML-DSA.KeyGen() 
def KeyGen():
    # 1. 選擇隨機種子 ξ
    xi = "72C3C5E0CC9F332F49D0FC0FD6399DA75645A3E33DBF56F1E96897662D0A9B37"
    input_data = hex_to_bytes(xi)
    # 2. 扩展種子 ρ、ρ' 和 K
    H_xi = shake256(input_data,1024)
    p = H_xi[:32]
    p_prime = H_xi[32:96]
    K = H_xi[96:128]
    # # 3. 生成矩陣 Â = ExpandA(ρ)
    A_hat = ExpandA(p)
    # # 4. 生成多項式向量 (s1, s2) = ExpandS(ρ')
    s1, s2 = ExpandS(p_prime)
    # 5. 計算 t = NTT^-1(A_hat ∘ NTT(s1)) + s2
    s1Hat = [NTT(s) for s in s1]
    s1Hat = np.array(s1Hat)
    A_NTT_s1 = NTT_dot(A_hat,s1Hat)
    aHat_mul_s1Hat = [NTT_inv(s) for s in A_NTT_s1]
    t = []
    for i in range(ML_DSA["k"]):
        d = []
        for k in range(256):
            sum = aHat_mul_s1Hat[i][k] + s2[i][k]
            d.append(sum)
        t.append(d)
    # 6. 压缩 t = Power2Round(t)
    t1 = []
    t0 = []
    for ti in range (ML_DSA["k"]):
        ta1 = []
        ta0 = []
        for tp in range(256):
            t1_temp,t0_temp = Power2Round(t[ti][tp])
            ta1.append(t1_temp)
            ta0.append(t0_temp)
        t1.append(ta1)
        t0.append(ta0)
    # 7. 生成公鑰 pk
    pk = pk_encode(p, t1)
    # 8. 生成私鑰 sk
    tr = shake256(pk,512)
    sk = sk_encode(p, K, tr, s1, s2, t0)
    return pk, sk

# 算法 2 ML-DSA.Sign(sk,M)
def Sign(sk,M):
    (p,K,tr,s1,s2,t0) = sk_decode(sk)
    # print(p)
    # print(K)
    # print(tr)
    s1_hat = [NTT(si) for si in s1]
    s2_hat = [NTT(si) for si in s2]
    t0_hat = [NTT(ti) for ti in t0]
    A_hat = ExpandA(p)
    # print(A_hat)
    # print(s1_hat)
    # print(s2_hat)
    # print(t0_hat)

    u = tr + M
    u = shake256(u,512)
    rnd = "0000000000000000000000000000000000000000000000000000000000000000"  
    rnd = hex_to_bytes(rnd)
    p_prime = K + rnd + u                                                                                                                        
    p_prime = shake256(p_prime,512)
    # print(p_prime)s

    ka = 0
    z = None
    h = None
    # for i in range(1):
    while z == None and h == None:
        y = ExpandMask(p_prime,ka)
        y_hat = [NTT(yi) for yi in y]
        w = NTT_dot(A_hat,y_hat)
        w = [NTT_inv(wi) for wi in w]
        w1 = [HighBits(w1i) for w1i in w]
        w1 = w1Encode(w1)
        c_tilde = u + w1 
        c_tilde = shake256(c_tilde,2*ML_DSA["lamda"])
        c1_tlide = c_tilde[:32]
        c2_tlide = c_tilde[32:] #256 -> 2*lamda-256
        c = SampleInBall(c1_tlide)
        c_hat = NTT(c)
        # print(s1_hat)
        # print(c_hat)
        cs1 = NTT_dot_l(s1_hat,c_hat)
        cs1 = [NTT_inv(csi) for csi in cs1]
        # print(cs1)
        cs2 = NTT_dot_k(s2_hat,c_hat)
        cs2 = [NTT_inv(csi) for csi in cs2]
        # print(cs2)
        z = array_plus_l(y,cs1)
        # print(z)
        temp = array_minus_k(w,cs2)
        r0 = [LowBits(w1i) for w1i in temp]
        # print(r0)
        if infinity_norm(z) >= ML_DSA["gamma_1"] - ML_DSA["beta"] or infinity_norm(r0) >= ML_DSA["gamma_2"] - ML_DSA["beta"]:
            z = None
            h = None
        else:
            ct0 = NTT_dot_k(t0_hat,c_hat)
            ct0 = [NTT_inv(cti) for cti in ct0]
            # print(ct0)
            zero_array = [[0]*256] * ML_DSA["k"]
            w_minus_cs2 = array_minus_k(w,cs2)
            w_minus_cs2_pluse_ct0 = array_plus_k(w_minus_cs2,ct0)
            # print(w_minus_cs2_pluse_ct0)
            minus_ct0 = array_minus_k(zero_array,ct0)
            # print(minus_ct0)
            h,true_num = MakeHint(minus_ct0, w_minus_cs2_pluse_ct0)
            # print(h)
            if infinity_norm(c_tilde) >= ML_DSA["gamma_2"] or true_num > ML_DSA["omega"]:
                z = None
                h = None    
        ka = ka + ML_DSA["l"]
    # print(true_num)
    z_mod = []
    for i in range(ML_DSA["l"]):
        z_temp = []
        for j in range(256):
           z_temp.append(mod_pm(z[i][j]))
        z_mod.append(z_temp)
    Sigma = sigEncode(c_tilde,z_mod,h)
    # print(Sigma)
    return Sigma

# 算法 3 ML-DSA.Ver(sk,M)
def Ver(pk,M,signature):
    rho,t1 = pk_decode(pk)
    # print(rho)
    # print(t1)
    c_tilde,z,h = sigDecode(signature)
    # print(c_tilde)
    # print(z)
    print(h)
    if h == None:
        return False

    A_hat = ExpandA(rho)
    # print(A_hat)
    tr = shake256(pk,512)

    # test = "D26AF4F24DE50EBEDA020DFC6F841B0A2D83D2781C06D8B3DF8EDA97A7EA4F9913ABEE9858F88F8A2F52C13DF2DE4BA023BAA5B3CB0ED941E077A08AE3F14035DB8494BA19C4118FB15D0ACF4254FD37483FCF4748FD1844F717CE6F69589E61772CFEFA7F9758653409D4EE5A264B834E60D6BB96499EBEB2B06B0BA874BF31E641394CFAA6A2D30DDB8F045876208D2F51DE15E205E8C91B87ECEB05FF3183271B2649665DD3CC49BFDB998D539DA809305516BBBE9C906021191C5223E525A8FC3616A1765EC3F9C5DB53CC337E039F186ACFEA91148EE2A79CCA3689EDB62AAF28B5D752FDE265EE5280B519726C1CA9803295C674B7EFAFA4D61B306A79E3F6E7A887C2FB535B3B0FB3D9EBC87603EAFEF170C1F1D28E99BB"
    # test = hex_to_bytes(test)
    mu = shake256(tr + M,512)
    print(tr)
    print(mu)
    # print(len(mu))
    c1_tiide = c_tilde[:256]
    c2_tilde = c_tilde[256:256 + 2*ML_DSA["lamda"] - 256]
    c = SampleInBall(c1_tiide)
    z_hat = [NTT(zi) for zi in z]
    Ah_d_zh = NTT_dot(A_hat,z_hat)
    c_hat = NTT(c)
    t1_hat = [NTT(ti) for ti in t1]
    for i in range(ML_DSA["k"]):
        for j in range(256):
            t1_hat[i][j] = (t1_hat[i][j] * (2**ML_DSA["d"])) % ML_DSA["q"]
    ch_d_t12d = NTT_dot_k(t1_hat,c_hat)
    w_prime_approx = array_minus_k(Ah_d_zh,ch_d_t12d)
    w_prime_approx = [NTT_inv(wi) for wi in w_prime_approx]
    w1_prime = []
    for i in range(ML_DSA["k"]):
        w1_prime_temp = []
        for j in range(256):
            w1_prime_temp.append(UseHint(h[i][j],w_prime_approx[i][j]))
        w1_prime.append(w1_prime_temp) 
    w1En = w1Encode(w1_prime)
    c_prime_tilde = shake256(mu + w1En,2 * ML_DSA["lamda"])
    # print(c_tilde)
    # print(c_prime_tilde)
    return (infinity_norm(z) < (ML_DSA["gamma_1"] - ML_DSA["beta"])) and (c_prime_tilde == c_tilde)


# 算法 4: IntegerToBits(x,α)
def IntegerToBits(x, alpha):
    y = [0] * alpha
    for i in range(alpha):
        y[i] = x % 2
        x = x // 2
    return y

# 算法 5:  BitsToInteger(y)
def BitsToInteger(y):
    x = 0
    alpha = len(y)
    for i in range(1, alpha + 1):
        x = 2 * x + y[alpha - i]
    return x

# 算法 6: BitsToBytes(y) 
def BitsToBytes(y: list) -> bytearray:
    """
    將位元串 y 轉換為位元組串
    :param y: 位元串
    :return: 位元組串 z
    """
    c = len(y)
    z = bytearray((c + 7) // 8)  # 初始化位元組串
    for i in range(c):
        z[i // 8] += y[i] * (2 ** (i % 8))
    return z

# 算法 7: BytesToBits(y)
def BytesToBits(z):
    z = bytearray(z)
    d = len(z)  # Length of the byte string
    y = [0] * (d * 8)  # Initialize the bit string to hold 8 bits for each byte
    for i in range(d):
        for j in range(8):
            y[8 * i + j] = z[i] % 2  # Get the least significant bit
            z[i] = z[i] // 2  # Shift the byte right
    return y

# 算法 8: CoefFromThreeBytes(b0,b1,b2)
def CoeffFromThreeBytes(b0, b1, b2):
    if b2 > 127:
        b2 = b2 - 128
    z = (b2 << 16) + (b1 << 8) + b0
    if z < ML_DSA["q"]:
        return z
    else:
        return None

# 算法 9: CoefFromHalfByte(b) 
def CoeffFromHalfByte(b):
    if ML_DSA["eta"] == 2 and b < 15:
            return 2 - (b % 5)
    else:
        if ML_DSA["eta"] == 4 and b < 9:
            return 4 - b
        else:
            return None
    
# 算法 10: SimpleBitPack(w,b) 
def SimpleBitPack(w, b):
    z = []
    for i in range(256):
        z.extend(IntegerToBits(w[i], b.bit_length()))
    return BitsToBytes(z)

# 算法 11: BitPack(w,a,b) 
def BitPack(w, a, b):
    z = []
    for i in range(256):
        z.extend(IntegerToBits(b - w[i], (a + b).bit_length()))
    return BitsToBytes(z)

# 算法 12: SimpleBitUnpack(v,b)
def SimpleBitUnpack(v, b):
    c = b.bit_length()
    z = BytesToBits(v)
    w = [BitsToInteger(z[i*c:(i+1)*c]) for i in range(256)]
    return w

# 算法 13: BitUnpack(v,a,b) 
def BitUnpack(v, a, b):
    c = (a + b).bit_length()
    z = BytesToBits(v)
    w = [0] * 256
    for i in range(256):
        bti = BitsToInteger(z[i*c:(i+1)*c])
        w[i] = b - bti
    return w

# 算法 14: HintBitpack(h) 
def HintBitPack(h):
    # 初始化一個足夠大的陣列來存儲結果
    y = [0] * (ML_DSA["omega"] + ML_DSA["k"])
    index = 0
    for i in range(ML_DSA["k"]):
        for j in range(256):
            if h[i][j] != 0:
                y[index] = j
                index = index + 1
        y[ML_DSA["omega"] + i] = index
    return y

# 算法 15: HintBitUnpack(y) 
def HintBitUnpack(y):
    h = [[0] * 256 for _ in range(ML_DSA["k"])]
    index = 0
    for i in range(ML_DSA["k"]):
        if y[ML_DSA["omega"] + i] < index or y[ML_DSA["omega"] + i] > ML_DSA["omega"]:
            return None
        First = index
        while index < y[ML_DSA["omega"] + i]:
            if index > First:
                if y[index - 1] >= y[index]:
                    return None
            h[i][y[index]] = 1
            index += 1
    for i in range(index,ML_DSA["omega"]):
        if y[i] != 0:
            return None
    return h

# 算法 16 pkEncode(ρ,t1)  
def pk_encode(p, t1):
    pk = p
    # print(pk)
    # print(t1)
    for i in range(ML_DSA["k"]):
        # print(i)
        packed_t = SimpleBitPack(t1[i], t1_coff_max)
        pk = pk + packed_t
    return pk

# 算法 17 pkDecode(pk) 
def pk_decode(pk):
    rho = pk[:32]
    t1 = []
    for i in range(ML_DSA["k"]):
        t1_i = SimpleBitUnpack(pk[(i * 320 + 32):(i * 320 + 32 + 320)],t1_coff_max)
        t1.append(t1_i)
    return rho, t1

# 算法 18 sk_encode(ρ,K,tr,s1,s2,t0) 
def sk_encode(p, K, tr, s1, s2, t0):
    sk = p + K + tr
    for si in s1:
        packed_si = BitPack(si, ML_DSA["eta"], ML_DSA["eta"])
        sk = sk + packed_si
    for si in s2:
        packed_si = BitPack(si, ML_DSA["eta"], ML_DSA["eta"])
        sk = sk + packed_si
    for ti in t0:
        packed_ti = BitPack(ti, 2**(ML_DSA["d"] - 1)-1, 2**(ML_DSA["d"] - 1))
        sk = sk + packed_ti
    return sk

# 算法 19 sk_(sk)
def sk_decode(sk):
    p = sk[:32]
    K = sk[32:64]
    tr = sk[64:128]
    index = 128
    length = 32*((2*ML_DSA["eta"]).bit_length())
    y = []
    for i in range(ML_DSA["l"]):
        y.append(sk[index + length * i : (index + length * (i + 1))])
    index = (index + length * (i + 1))
    z = []
    for i in range(ML_DSA["k"]):
        z.append(sk[index + length * i : (index + length * (i + 1))])
    index = (index + length * (i + 1))
    length = 32*ML_DSA["d"]
    w = []
    for i in range(ML_DSA["k"]):
        w.append(sk[index + length * i : (index + length * (i + 1))])
    index = (index + length * (i + 1))
    s1 = []
    for i in range(ML_DSA["l"]):
        s1.append(BitUnpack(y[i],ML_DSA["eta"],ML_DSA["eta"]))
    s2 = []
    for i in range(ML_DSA["k"]):
        s2.append(BitUnpack(z[i],ML_DSA["eta"],ML_DSA["eta"]))
    t0 = []
    for i in range(ML_DSA["k"]):
        t0.append(BitUnpack(w[i], 2**(ML_DSA["d"] - 1) -1, 2**(ML_DSA["d"] - 1)))
    return p, K, tr, s1, s2, t0

# 算法 20 sigEncode(c˜,z,h)
def sigEncode(c, z, h):
    sigma = c
    for zi in z:
        packed_zi = BitPack(zi, ML_DSA["gamma_1"] - 1, ML_DSA["gamma_1"])
        sigma = sigma + packed_zi
    packed_h = HintBitPack(h)
    packed_h = bytearray(packed_h)
    sigma = sigma + packed_h
    return sigma

# 算法 21 sigDecode(σ)
def sigDecode(sigma):
    index = ML_DSA["lamda"]//4
    c = sigma[:index]
    z = []
    for i in range(ML_DSA["l"]):
        z.append(BitUnpack(sigma[index : index + 32 * ((ML_DSA["gamma_1"] - 1).bit_length() + 1)], ML_DSA["gamma_1"] - 1, ML_DSA["gamma_1"]))
        index = index + 32 * ((ML_DSA["gamma_1"] - 1).bit_length() + 1)
    h = HintBitUnpack(sigma[index:])
    return c, z, h

# 算法 22 w1Encode(w1) not yet test
def w1Encode(w1):
    w1_tilde = bytearray()
    for i in range(ML_DSA["k"]):
        packed_coeff = SimpleBitPack(w1[i], (ML_DSA["q"] - 1) // (2 * ML_DSA["gamma_2"]) - 1)
        w1_tilde = w1_tilde + packed_coeff
    return w1_tilde

def hex_to_bytes(hex_string: str) -> bytes:
    """
    將16進制字串轉換為位元組
    :param hex_string: 16進制字串
    :return: 對應的位元組(bytes)
    """
    # 去除可能的空格或前綴 '0x'
    hex_string = hex_string.replace(" ", "").replace("0x", "")
    
    # 將16進制字串轉換為位元組
    return bytes.fromhex(hex_string)

def bytes_to_bits(byte_data: bytes) -> str:
    """
    將位元組轉換為位元表示
    :param byte_data: 輸入的位元組
    :return: 對應的位元串（每個位元用 '0' 或 '1' 表示）
    """
    # 將每個位元組轉換為 8 位的二進制位元串，然後合併
    bit_string = ''.join(f'{byte:08b}' for byte in byte_data)
    return list(map(int, bit_string))

# 算法 23 SampleInBall(ρ) 
def SampleInBall(p):
    c = [0] * 256
    ctx = hashlib.shake_256()
    ctx.update(p)
    s = ctx.digest(8)
    h = BytesToBits(s)
    test = ctx.digest(8000)
    cnt = 8
    for i in range(256 - ML_DSA["tau"],256):
        j = test[cnt]
        cnt = cnt + 1
        while j > i:
            j = test[cnt]
            cnt = cnt + 1
        c[i] = c[j]
        c[j] = (-1)**(h[(i + ML_DSA["tau"] - 256)])

    return c 

# 算法 24 RejNTTPoly(ρ) 
def RejNTTPoly(p):
    a = [None] * 256  # Initialize polynomial coefficients
    H_p = shake128(p, 8000)  # Get more bytes than needed
    j = 0
    c = 0
    while j < 256:
        a[j] = CoeffFromThreeBytes(H_p[c], H_p[c+1], H_p[c+2])
        c += 3
        if a[j] is not None:
            j += 1
    return a
    
# 算法 25 RejBoundedPoly(ρ)
def RejBoundedPoly(p):
    a = [None] * 256  # Polynomial coefficients initialization
    hash_output = shake256(p, 2048)  # Get more bytes than needed
    j = 0  # Coefficient index
    c = 0  # Hash byte index
    while j < 256:
        z = hash_output[c]
        z0 = CoeffFromHalfByte(z % 16)  # Lower nibble
        z1 = CoeffFromHalfByte(z // 16)  # Upper nibble
        if z0 is not None:
            a[j] = z0
            j += 1
        if z1 is not None and j < 256:
            a[j] = z1
            j += 1
        c += 1  # Move to next byte in hash output
    return a
 
# 算法 26 ExpandA(ρ)
def ExpandA(p):
    A = np.zeros((ML_DSA["k"], ML_DSA["l"]), dtype=object)
    for r in range(ML_DSA["k"]):
        for s in range(ML_DSA["l"]):
            r_prime = IntegerToBits(r, 8)
            r_prime = BitsToBytes(r_prime)
            s_prime = IntegerToBits(s, 8)
            s_prime = BitsToBytes(s_prime)
            seed = p + s_prime + r_prime
            A[r, s] = RejNTTPoly(seed)
    return A

# 算法 27 ExpandS(ρ) 
def ExpandS(p):
    s1 = [None] * ML_DSA["l"]
    s2 = [None] * ML_DSA["k"]
    for r in range(ML_DSA["l"]):
        r_prime = IntegerToBits(r,16)
        r_prime = BitsToBytes(r_prime)
        seed = p + r_prime
        s1[r] = RejBoundedPoly(seed)
    for r in range(ML_DSA["k"]):
        r_prime = IntegerToBits(r + ML_DSA["l"], 16)
        r_prime = BitsToBytes(r_prime)
        seed = p + r_prime
        s2[r] = RejBoundedPoly(seed)
    return s1, s2

# 算法 28 ExpandMask(ρ, µ) 
def ExpandMask(p, mu):
    c = 1 + (ML_DSA["gamma_1"] - 1).bit_length()
    s = [None] * ML_DSA["l"]
    p = BytesToBits(p)
    for r in range(ML_DSA["l"]):
        n = IntegerToBits(mu + r, 16)
        H = p + n
        H = BitsToBytes(H)
        H = shake256(H, 160000)
        v = H[0:32*c*(r+1)]
        s[r] = BitUnpack(v, ML_DSA["gamma_1"] - 1, ML_DSA["gamma_1"])
    return s

# 算法 29: Power2Round(r)
def Power2Round(r):
    r_plus = r % ML_DSA["q"]
    r0 = r_plus % (2**ML_DSA["d"])
    if r0 > (2 ** (ML_DSA["d"] - 1)):  # 確保 r0 在 -2^(d-1) 到 2^(d-1) 之間
        r0 -= 2 ** ML_DSA["d"]
    r1 = (r_plus - r0) // (2 ** ML_DSA["d"])
    
    return (r1, r0)

# use with Decompose_r0/Decompose_r1
def mod_plus_minus(x, alpha):
    result = x % alpha
    if result > alpha // 2:
        result -= alpha
    return result

# 算法 30: Decompose(r)
def Decompose(r):
    alpha = 2 * ML_DSA["gamma_2"]
    r_plus = r % ML_DSA["q"]
    r0 = mod_plus_minus(r_plus, 2 * ML_DSA["gamma_2"])
    if (r_plus - r0) == (ML_DSA["q"] - 1):
        r1 = 0
        r0 = r0 - 1
    else:
        r1 = (r_plus - r0) // alpha 
    return r1,r0


# 算法 31: HighBits(r)
def HighBits(r):
    r1 = []
    for ri in r:
        r1_temp,r0 = Decompose(ri)
        r1.append(r1_temp)
    return r1

# 算法 32: LowBits(r)
def LowBits(r):
    r0 = []
    for ri in r:
        r1,r0_temp = Decompose(ri)
        r0.append(r0_temp)
    return r0

# 算法 33: MakeHint(z, r)
def MakeHint(z, r):
    bol_list = []
    r_plus_z = array_plus_k(r,z)
    true_num = 0
    for i in range(ML_DSA["k"]):
        d = []
        r1 = HighBits(r[i])
        v1 = HighBits(r_plus_z[i])
        for j in range(256):
            bol = int(r1[j] != v1[j])
            if bol == 1:
                true_num = true_num + 1
            d.append(bol)
        bol_list.append(d)
    return bol_list,true_num

# 算法 34: UseHint(h, r)
def UseHint(h, r):
    m = (ML_DSA["q"] - 1) // (2 * ML_DSA["gamma_2"])
    r1, r0 = Decompose(r)
    if h == 1 and r0 > 0:
        r1 = (r1 + 1) % m
    elif h == 1 and r0 <= 0:
        r1 = (r1 - 1) % m
    return r1

# NTT use to bit reverse
def brv(k):
    return int('{:08b}'.format(k)[::-1], 2)

# NTT
def NTT(w):
    w_hat = np.array(w, dtype=np.int64)
    k = 0
    length = 128
    while length >= 1:
        start = 0
        while start < 256:
            k = k + 1
            zeta = pow(1753, brv(k), ML_DSA["q"])
            for j in range(start, start + length):
                t = (zeta * w_hat[j + length]) % ML_DSA["q"]
                w_hat[j + length] = (w_hat[j] - t) % ML_DSA["q"]
                w_hat[j] = (w_hat[j] + t) % ML_DSA["q"]
            start += 2 * length
        length //= 2

    return w_hat

# INV_NTT
def NTT_inv(w_hat):
    w = np.array(w_hat, dtype=np.int64)
    length = 1
    k = 256
    while length < 256:
        start = 0
        while start < 256:
            k -= 1
            zeta = -pow(1753, brv(k), ML_DSA["q"])  # 使用 brv(k) 反轉位
            for j in range(start, start + length):
                t = w[j]
                w[j] = (t + w[j + length]) % ML_DSA["q"]
                w[j + length] = (t - w[j + length]) % ML_DSA["q"]
                w[j + length] = (w[j + length] * zeta) % ML_DSA["q"]
            start = start + 2 * length
        length *= 2
    f = 8347681
    for j in range(256):
        w[j] = (f * w[j]) % ML_DSA["q"] 
    return w

# NTT_dot
def NTT_dot(A,s):
    A_NTT_s = []
    for i in range(ML_DSA["k"]): 
        d = []
        for k in range(256):
            sum = 0
            for j in range(ML_DSA["l"]):
                sum = (sum + (A[i][j][k] * s[j][k]) % ML_DSA["q"]) % ML_DSA["q"]
            d.append(sum)
        A_NTT_s.append(d)
    return A_NTT_s

# NTT_dot with l
def NTT_dot_l(A,s):
    A_NTT_s = []
    for i in range(ML_DSA["l"]): 
        d = []
        sum = 0
        for k in range(256):
            sum = ((A[i][k] * s[k]) % ML_DSA["q"]) % ML_DSA["q"]
            d.append(sum)
        A_NTT_s.append(d)
    return A_NTT_s

# NTT_dot with k
def NTT_dot_k(A,s):
    A_NTT_s = []
    for i in range(ML_DSA["k"]): 
        d = []
        sum = 0
        for k in range(256):
            sum = ((A[i][k] * s[k]) % ML_DSA["q"]) % ML_DSA["q"]
            d.append(sum)
        A_NTT_s.append(d)
    return A_NTT_s

def array_minus_k(A,B):
    d = []
    for i in range(ML_DSA["k"]):
        w = []
        for j in range(256):
            d_temp = (A[i][j] - B[i][j]) % ML_DSA["q"]
            if(d_temp < 0 ):
                d_temp = d_temp + ML_DSA["q"]
            w.append(d_temp)
        d.append(w)
    return d

def array_plus_l(A,B):
    d = []
    for i in range(ML_DSA["l"]):
        w = []
        for j in range(256):
            d_temp = (A[i][j] + B[i][j]) % ML_DSA["q"]
            if(d_temp < 0 ):
                d_temp = d_temp + ML_DSA["q"]
            w.append(d_temp)
        d.append(w)
    return d

def array_plus_k(A,B):
    d = []
    for i in range(ML_DSA["k"]):
        w = []
        for j in range(256):
            d_temp = (A[i][j] + B[i][j]) % ML_DSA["q"]
            if(d_temp < 0 ):
                d_temp = d_temp + ML_DSA["q"]
            w.append(d_temp)
        d.append(w)
    return d


def mod_pm(w):
    result = w % ML_DSA["q"]
    # 如果結果超過 q/2，將其調整到 (-q/2, q/2] 範圍
    if result > ML_DSA["q"] // 2:
        result -= ML_DSA["q"]
    
    return result

def infinity_norm(elements):
    max_norm = 0
    if isinstance(elements[0], list):
        for row in elements:
            for w in row:
                norm = abs(mod_pm(w))
                max_norm = max(max_norm, norm)
    else:
        for w in elements:
            norm = abs(mod_pm(w))
            max_norm = max(max_norm, norm)
    return max_norm

def shake256(data: bytes, output_length: int) -> bytes:
    output_length = output_length // 8
    shake = hashlib.shake_256()
    shake.update(data)
    return shake.digest(output_length)

def shake128(data: bytes, output_length: int) -> bytes:
    output_length = output_length // 8
    shake = hashlib.shake_128()
    shake.update(data)
    return shake.digest(output_length) 



# pk,sk = KeyGen()
# print(pk)
# print(sk)
# M = "4D3C4D952A1DAC151736AE9D0AD81CD37F7C492539FCC916A4B2251309E06CED54D7145868D145BC8D16F8B364E5D6026E113BEC4824F6BFAE3C9F6C8B888EC6B8254CE59E9E8E158EB04077841243EE3A89D25C0B30B4A64B723697330AA87663B20EA4513189558466D264C79088415EFA09DE9B64AB01B640B288D1D5562ED744E80CAF0B6E2C29FFA1C321129EBC70CAA73DCA7DCE899571260B2E7DA1B47CEC5BB00FD66AF8B89BB84392897BDD1A5EC7186670DB81604E0B949B5AB1D19522A3F0828D0E77B300A63EDCB74C48F9A01CA91816FBEE011A5B0145C6A0B4EFD5A3008A91E0B1AC96DD8CB9410D56A952E74B7FB684A0B166E5F0DF9AD100EE1C9E3B7B851B4CBF337A3328DB13977451E992C4A0B454BAC5E3A2D0E64D106DC47C216E0C0AC11B0F7C48589E573051133D01F29579C7E659F8FB8E6539B0F618D053F4323AD0237A58949F689458ACC109BEB7C81952A879A10BF8BC01CE057E936B62017E226DD66AB2470852C000A618B9B130050F6B047746D068FE7D3CC1277E4FF4400F372D50A85F469B4C7A35AA7FE88DD923ACEF5FFF47A95F971EFEA6B65D33E65F20173C5BA5A320DD16CAAB59AA7A7BB99956EB5ED54EB93E89C887A30D6D384345E21291B8E9C6CDCBE2671F810A058B858220146A2161B7412CE2DB817CC8C99528195F567A92E198330AAA418A5FAB754E27221A2165EC4D50B391BB8AB2BECCAA449CA1D4D3D5C17E28573048452EE4120693505515CF8D1E2F8984D363464DB786E9B8B7BDEDFA2301A21F3C469F013E27742405CFD0D15E70BE0560E8B18C82327861A8DF64200A51E69D2791D41E1E12BF371664270AFBBE1C84FF19D11D4C233ECDB8033BC79BC7967C410C13E8E3F9340F848510760DABCCAB6EF7BB87398B1421E5804F6D41ABC09E6542D72B87115F1281450C66AF3BF4FDC21CB9B8C27D0FC6DDFA73732A877CB7D7C09B8E9F4603D9865E4AF91C58E9EF6FD9A32C91EEAAEF170BF4F44BF586D789EF4571DEBE6FFF0C43E842617FA50FA6EAC8C7F70EB680BE717688188A430484F3388F6219A70EA38BF3C6DBBC7FF3A749D8C8E51A1365AE372988D248F9FC0F2B67E896CBC86D2AED35F7AD8D4E93C21DA09E0204C7DB92FAFA7119A63BD0CC00A029CE7DB93DF34C33ECF673D48CE3F40948DE86CA5467CC159960B329F560B20E5C8AC37AC4C8960B49B455075489E7217D6BC53AEE7C19B3FDE9FFF667EAE89AA6CE8C415E807B348A14598329A32D9E508C3409DF18EB426BDBFDDD88AEB3A9BCB9D84C2388AD79AABFA3445F80A9A68EF74096E34516CB5316DF599E5836F123271CF729472952E06C817A67C219382F22C4B0A16F7B7DDE9ECF4AF6927BBF4424F43FCEB1A48F1F2CBD98E7593464EBDE45D604B6AF95E32AE728D921B390F712ADC280257F4420741C0D29E0E6B98EC1708569381BC845420DB0C1BDC9A23DAEC209378A01703B9C16C10FC29763A52FEE64F0A728198513361CD981DAC739937FC472CCCF666E61DA3D90C3656F0BBDE6B942D8A0496C9BC703F7424BF00848800AAD519347A4747676C81088109A2B67848EE0A08BD1409E774434EFFE754BDECAFF2328EDC30FDB85B45488DE0A5D9052397F9DDB0F13865DCA85A36F6B43B84ED044E5F40BB960E56DD0CD6EC08C37B017FEEDBA4A7F20A174E1146C441DB99A2BF34BB8D8FCAEB874B2313AF2E20B01D38B56B42451047EAFF592236CB241857754F6E2DA3E4FAD070FD195B641567375B6F2744FE16996D7A73D095F5CFFDD50A96508FBECF802625E5F168DA08C8D5198BB2702F1CBDEA8221BCFC301195B717A0D174EEC9BB96E7C49E15CD2A26B933E0C6BB11D702F1A21D33BE48039E89E38C2A5E96F55A557359BBC8E191719EC5E5669B2F168912C9177B320A5762474CB2303F54E78F4DBB914EA354F8C9A3E81342A10ACF5FD4A3D8CD6F85A204E165D59E4FD12D5E5E900AC94DB984DD8A5A72372D8B5D8958EC7F9E64CEA4E560A8D9525CB24D3B2F36ED7D46F897229A776E7E422838D4E2B551B28D0127F2B7644F35FBC35BEF9D856EF447F699151F73AA70CEEA55F6193060762B28FA150A83344A2E23B9E5E1B103805DE85C520EACCFD67A5C390334B036028D4B696AE3D6F6DD80304F7CF915F564409AE65AB7504D8FED434966AA4D4DB3A3C90B160332FB8E6A33A392122E3C02F27C38E37B8B217958912D0AB987D232B65D7FDF3F28CD507D53F5CAACE75224AA3F63A4D4570627561AA146A32645C89BA18CD4C7D2AC0D9123C89AA7D4AEE9CF811DC877D7D0321AB5C7EAE86F2EBD61AAE681EB53EEA73D0D7532937AAF8F8A23E0AE64FCBAF782169422ADB6CE8F3F003CD2EE9EFC37E5EA1A8902D3D1246A89736C6C7C9A46FE2D2DB3BEC00E69166ABD213A6D30494244FEE28050BFAE566DCC91C9528883011F215995DC92E577421C9645478FD3C3D7D8FE06BD1824AA20B4A67CF9E8C2A69C031E4E1FCBCBB6170D60838C61AF3731C7FD4DE4D6277FD6652B63318CF093F7DF46D800368A71333BA657171ADCE4D360E249B32F49F93E38C22ECF79C89647564B7F83E26A59D403B239A25F7629CEC50EDE1EFB58D9017ED44CE34A3136518FA009C8BEC057BA054C794EA0F49F3C581FD91009835946742B806D115D4E2DD109E1797F7DB5575CF233980B2D072D247E704EF40A6DD6651369C67B576FA7DE4C794E469EB2DB8C0E424D07CA01753671116FDCB9B37C0517686D85111B8E12A530C25F0D01ECB20E259CCCDB0A081ACA5CD06E9FE50D79B9A7412E02F41B53CE3555E986833D253532CA5D27A4F0C72FB698CADE01B36CF94C5A05907AB3AC631455B4AE91803F2A3A83E9EE23EB0538840E1C9408F73205D7930AF7CAA7B4EEC2D47A71B99C07B09FB4BA1ECC036BAAF5230D600550CEBFCAF49A19D63B3B50016CC8077D97C27376E2AAA370BB3CA213968D242C11AC0A341"
# M = hex_to_bytes(M)

# sk = "D26EE59A89F67C98B20F890B03422C8027B776FC305BEF422CDED403AA705DA5DC380AD909E3C13A76F7F59BDD27A843F5F9A1B8E5B7B524EC445A916B7A44A15167716BC609B3EC0C653B210C6569BA2F8233E7F6E404B92EB21F39729FEBC06A644087C75FA7DA3DDC5B85A89F55C9F87A15014E27AB325EBEE0FE472B2F56205844860382534018828866441476575685641203648087665585183625516555420058871751602717711246115635711801273601127806468005021161768110481565564313804086156224775253365085726676702542128777015217656384221466167018541712560775653305356788352067346543727338426471425281415038533202656128851671300117755513452307351315370854301872372157587303156081110321112258736404438264705244308745330557358455160473004531650442427724303753273643545546151241081547412433078243311343703723518581388573234883002524138203118818106712726275005164485846703435423180316086652647174338637385102777331112452328027048826136833604027623520567678561007443300118026417762172470414100567684236755276750265038807023654313530500201746332586762137686700431224203777868426234607501375807606118643643343182854487118067375717216763686234631445727470521225615865012624304163885146650645168324156757125027631761181378335367286426405258178463767046744346405385558607416365312311607655783032614171118036426333182624236747864807656353823246577001576547601536137245648167881548355703441616635365661535127864121615460226475308628856173321321610874562553506784723735385386463056370235073236822680783606365575167372423481370273787321706274756640515832755317524417643527131782776733023626563226284344414664814180751873017473606630568447604505822478245472545717704487614714872060204431705604477512622755208754111644114533555057070674013756756613028602834613507528705643218236456378337317881601264762752721064334675027466164547381066466654324575825520882682277558861126808652842067242706502602822135413806761150412241623142132062854561462005282463527054222067084232463834703022563303120640700613028248186135862267807514517034808871887028651376603357053471356848232460123720236623604868157088117331708032612544633466027487881011822577840213584603838688167482874577534023608684717551178060878605807013607371146861810111452118252851727546664116442725718666627745565706128063346337837125850568444871521347471236266350161674306083251415448031242478881077307231468143328543380706263487802348512856658522881606460085147711847660265787214085344812640116713686701544018882508606025375436400485704788868344567583740386811256420867877166077712432136288331062381178450376522316153520153726880635206125157517874821078632831518110002578434628677277256811181641133083303108474041885821315177237034415740262877735530252155663683621050363812382062703541636072037888130651437727453164255777504346625374221717666355341021461642300018161635551232553767782843483040236111880701245700154018276321853454261144802277261072016656336147062500850107086111551067005227866654812551566680414042612307370316834001206560231706668641615317857425305313402768758031066346812502214187812016774121074448086641371280564240151566227543442570306101083513862873685631407576010245281712830883456301434255351012FADA607976F6837B0DBB68127C5D2CCA1E3BFE9CE0441DAA2FC7F0145F96BFA473054009EFB11184E4718B045758DAB9E41CC03A8A581F86F05C9D76F3BBEFCEE4A67DCD2CE920CD15B7241D7BF641B462A72E287C3DB90AFF454ED1C8B0794AC1055BC6B4BE81669FE7154ED8FAB43BB21E2D787FED316B81CE03DA5019A0948BF4F19CE09D317736CF91FDDD4B42B29B9AA0C87D58C81D2A74F22F44AFEFDF6DD0BB2689BC4E54C42DE56F5FC6796941631931525D7B51FED90894F88B20BC819BE6F19D080EFC03E23CB034D06EAA41D552CCB07B42AE79486825EBEAEE22CE193D5B9174E20491E23F376E3EA9731981FDEE6E0C837A07C9A6575A038522C8F36FF0E481625E1D693C69E2B4B4910B35CFCD7AFF76301F15E580C5F2E4118CB9754D90ADC4140E4AA8DA02FF7502514652F07D14B0AFDD6DE58EB896CF51E562E0B7972E85D334EE77E09E7882EF080275786B91E1BDB949E94BCFBE45333D0CFD6305746A24B4B2AF2311F964151D4F89D12D1D88A6149351CB3294926A3B05051FA1F613F4854A1727E3FC195F4F5F99D7A6F6766A250839C090B4D81E71C242A58DEBE5DDCA556B97DE9790DB89ED15CEDCF7EBC6D44DC61881BE060F905CBB77025694FB382A66A2809A759AE66DE102CF059E9339C26112F76C50B39EF61ADF393B92B69BD88F6AC5E7EED1FA1A8BA7201696DBECC8FB9AFC1946C744D92F3ED30F8834C398F42C53720510D16817A8074A2F12D27FF98CFCFFDFF7D94FF793993991FD44C799D8BAA5E0BCC789D3F3EF467104BDBF2092509E530F920DA1F663A5E58AECA50EC6F1DC82986D37EE6C195D64E2D4960BEFB09D3EEAADBF9873340A5B86D29DE380DFC41A99D7350D9A5055706E3C2037245DF35B9DF14B810772C3A40887CA02CF5CD42993E360852219A9A384647CE912D95DFF0E80706A2696296C7290214CEC72EEB016D34E03FBF5E65F4795E714B35DE183FEE6CC6C35E349289CC8DBB37AE9F968CF0BC3654D3B82175B0C5AFFD9B1D421B7DCE8015AFD77520A983E1C1E9EB0708118FA4BBEE072157E7CD8CE9381091D3F1D4FC3980E5F8C95D54F4E6BB7AF368AF6BC9B332B80D7F8E76C2E203049C3380C5E0F5299DD6E57CD59AED1CCDC998F2FAE72C29A0C1D4025C34E506AF77760228DC3B8B680AC8A2FAD784EA6B86EF34F1842E66F46FB0F68F0101425D16341825DD6605DF6310E7C9811F4CB81EC3C7AE7CC6F528C782C6D33D6883E895B3A06E3D3EA84B03E3603394B44A1A3C289871A59269F4B80F4C7CF404A4B99A529A574BE46AA6B52B4E544FB7022C90904BE1C767FB8DB744B9C69FBC503C234F6618794F71AD8C95E5087F54B4F82154454C0E7386F21EECC0DDBAF454382A973BE4ECEFE846E0C21B60B56448E6E5EDDBAE084132A1397F16314047144ACADD6CC342447DB6A65365747A63C404AE623BC3EF1703C18B14FDA178AB7392E9EB6D2C9045EEFC8A7368DBCBA7F09CC88D6EA54505BFB82373819FB990F0F64C6FBE421E35CEBD9B79CE77BDF3C8946C58C6071757284E5B53B56DFEDB2EEF928DC9AE02BA21A2B5E284E285C9A6CB05710E2634CB3627C52E577F7E5CA7475607A7D2CCF1452F9BA703D322F69A47F16BD9851C7528D89B59C03B426AEBB3B372328CA9102F624E901DC8A315524B941706ECFE0AA8AEB0AF8EC33D2E1CA203B489AE23C03D880B83D738CC277EB6FF1C7DD31886C639C6C658396F60920D8A0A4E58278D63E5B393295FE8887E8F9F6A64C10CA241F699B99D72D13722E42D4615D9F3D0545E320D38EF809076F4216428C29D130F2F83052B9D0BA4A8A1872A242BDC59722281DDECE5407CBBDDBDB0B8C04E9385AD9660D252DD28AA881166694207BB04F9A24FA92216ACAF264C9F1CC200A5E2CBD2694C91238A8972496097B3BD3785345EE7171A9EB96619722C64571DE6327CD0345B788871D7D5D0D84EF2A47DDE6680B7743AD61B164E558B672E4CC4B46D6E6C236C2133965C8B3C7D0F240AB0EDEC78E8EAB4C80040A037F0080FA3B15ACC3EEA34208065EB6E6E21DA65601454E6DB037C08B051A1942DAB90C92B0BDC8C572C52F0AEF84B85F0444A6C15E84801448DE8147804F796A1A05341E75DF015FEEA7E191C461D3D3D7B2D74A9C4C7E18EAFE0966C26731F0A960461DE0387A917A6BBD645C4668030642D70DE30D9954556CDACDE00F82219E7A3EECC8354FC5A4388195CE568016C7C63661559EF65E2FF09F1C98A6668C23AE4863B04287A3BB6210B3F5689A3E7978517B95B0D06A831F28A3FF55B6053E38535B2AA97FD66B42980CDAF9E5DB6F1212BC23CC740BB7DDF8CD40391C0190F62A0A2A287DCC2AB8FA65C71675619C451EC07F3D67EE81A6370EA2144D82CE63CAEB4FD76E6FE4979FBC149BC54A9236D4CF23CD5C09E83DE5BD888F2EB03008BB9FBA0CD5CB79DDB62E2F9F8F2E11B2210DDD11590E21214015085A3CD8DD1665AD81D28D552B214D91550FFB3010102098E6F7649A5E06057998E25B4F789B2FF356299C589B1CE03D4AADDC9177B47974FBE205516B3A9E88F0B3955F133C29C1EDB94969E89B2DA7B64EE423A51672521CB4E1008D0AFCF68D6172A174F0ECABB5FB7648444032E6443CF9C7FA4ED4E1728427C2804699A143EDF11CD6CF9F5AFF6341A69DE7B7710C223C799861242C0D68841F36D9200122381EBF94D22258B38375C0D25DC1E3EEE00E312433CF8032F46EA0A0BCA36C679F5FFC82898372D631FA7368595ED7CB6571E8C00C16AFA4F4791E63813141D800111C1EDCEFD8872BEA41B2DD159676F23BF85C7DE07A30D2459EB16B24BDAD322C177B174BA83EAEB352B2C0D8140B33D50B0C9F2DDD39F305F9AB4565D3ADF35550F023F346900C59903CB972579395840D6A89169DA96D7012A821632E66821591FD3731EB068CBAF5F18589E7541CB4AEB0C4859020D0A3B99887D12E78F690073D29A242682D4677E2F904DFD7266E0514F6E460AD2F1FC5CE875D106432C5F91D6246D80AE5C7D8C4E4EE122F5FC58380391ED536CA4F073E2B55F5ED19751479CB3A71E72E8F330E086981169140A8AD069A49B1FD4EB950F9FB9084D1E702B957D081709FC510D31CE2EB1E42AB474D73A793231EC274EE399257DEC4B9D0704265A77E745F4CD8F9E4909FB9299304CE6AC7FA95C3F47B210DA388EE748ABD41CDEB3CBB187A40BB3C3F4150ADA3472DDB398DF8D8D5865EF27F54CBD4164DB0465DF7443E1D7782A2403387EF0118E8EB10283A39072C36A46E724165F49ED170A8FCC00FADF037EBFC652810697CD7108A56989491BA2232BED54BA167DB9D526FAD348B7787AE71557C59B38D1054CBE9BCB45E17BB146ADFC04F6816334D3D815BF73FBECF1C9D437D3A47A7862C286884B638DD7FB64BE01B7981D7CC82A90938EBDD9664DEBAF0E03A595368B89338AB076BD22AD579D04F1C7EA075D220F8CCDC0B9E372F5194AFE834D28"
# sk = hex_to_bytes(sk)
# signature = Sign(sk,M)

pk = "2D1E6BED8452EBF126EDE70CA0A2B50D03342D5B13B2AE210F4562A3BF670CB15CE925FD22F26242BAE310B3AA413B6E78D442D935D1728A3248CC205CCD8D3FD834955520CDFB2C73E90E608B2C3FA8B7D179FDDCC88111C9E84171E9709B535933E492B6819C6A92EDA25AC407771A8FEDB4E711FB89EB7BDFCCEAC53B4EF46B6FBEE132A9D7ADB436E74A6D671183AF311A7A31429B012117527585F7920F348A6911885A0208B66DE30793B13FE1D57BD951F7AAC0349A785D26DBF1F0A91E5C9F4FA7435C44A943F1381145EDEB1C8A05EEFFAB202CF62CEE7742363EE69D8E450FF67C3962D6FF97BC3D02D6DF4A35DA3F89A48833CDF290F0E9372F65A58865FD4044AD090992AA159EEEF72B0DA7CB3A5E0AEDD67D828BBACFE59EE462AB696BBAD0E5A9BB1F5A51E0FA5DD44D8EC0DC4306DF2367B24AA2FB752F82D844E4C0CE159E3FD6B4705F3BD0563E0A7A4B94BFBA012B9C8B9135F2DB4C8C8DD6EEC8658DF30559BE3A17A772105614EFB8C1BE18110BE670F839A5727DF947FBACFD1FC37133584415D37C932E7092FABBF2D09D25C4CF4AB8ECBE5D8B7FA47CABADE71E938392861E8D15A41C5B4225DA3D16D393F28550860A86356B14AB5F22D0CF037CEBB40EAC87A24142A0219300B6476F96D041D1C30E3C52D245AB6AE7A1E5FD73C5829D60628B6D87FC889C3EEFAEAAB61C18EED7511A96C4932505D3833DD83316144488E2AFC4EC591812B999C1C95F31790003F6C95514AA29087824AF1D991236D94AD950EF66FC7FF4BC3BA0F6FDF262CAA59D2B55B833BCA67AA51EE1145F94E2DCF05BBD4307D8B1E0813F845490BF2359923CA598AB7D99D2F0ED8E0BC99FAFB013EDC7DDB86172073DCC3573A0CF0CD97E93DC63B882ECF430CE4392EA5ED8C8A1EC79DCAE64D433EB538CFC4979BF7A28651E8CD521B08ECAADF8969A981000356D589AEF84848672BACD3866969BC283B065C1ABCF638C2DC342B27DF6B8F03D26218FAE4E96F25566BC6FEDE719D38DC0CD55205F10CADA09ED914A4333D382115C2F5DECCD54F96CE4E5F268BCE927B21DCAB5CD04011E92F5F601862B20209BB0F956D933D50AEC1BF4CED2B2C2D43F9A25768E29875264864AA57B5A91726EBE6D730A8D89538233704420BEE0B01B763043A55B8FAB7EB8615F43701B1A716156F913312A643314009872EC328809FB64463D5602D976D3AA900FBDF0F996437B621926226A9391EC0734F52232B36566E06B117F979F1A8946CE8FBDFD2FCC3DBFF283A430E10272F874E6219677E1578AF79EB331AFD8C5D720DCFDCF79060F1FE5843D0B9CB3C7ABB8F1C0D0B5C701E20E3BAF7EAC445A75500A761C13DB25D40D19754C02D9F3DF6DBBCF47A6AEF6D1FBF4B455D3A587A155FBBFCDF6A1645712759A11A3CE427084549312E13A0FFACAF22591F14D8F84B1B535ACE98177344D6F5D149DB9E1F03F3CE7AD48E68C5186F44AB4D098EC3A4EAB582F089E5A9D4530B085DF4AE792C6C8189308CE9A8CE2918D91577B37C880A231100D4EEF5107948EF83C3C2ED50326B8727FB9BCD795C43108EC6FEE11AFC0A2ECD7C80BBE15AEC917BE37E2408365DEB34EB415B35C14F65FA91F70B5239378B947F91D2B1E8DB1257EE5853C169FD0C2678B0DD2724E7430E1AFB866CB53DFC4FBA56D03F2AEEE90FED730AF339809EB75C73EC82FE7225F2F0ABDA42288281935831286EE72B426892FC7116EDD149822E7733EFA4675F940C18422BC7536C782D3AE6E0DBF6FC34B674919F34B12F283FD395644053A246A356912CFE493FE26CCD601A04A84A81D85E6830F3CE66DD2CBB1148CEC10B3634B9CF511E0F9866FA7C03B9D25D754CA404D26BA718E25F5A7E39B25207F2905B6271417672610ADA30603FE82855D01044DE06438385E831E219A3902F8F9698552E5EC6AAC9686A78869B5B57E031DA968CA450FF914D67BCF9C036FD1D96F013DF8F311F3291790E89BED589BF0BCC7BAF460C8AA30B42F228FD3AC18C2B7C47B319E0F7E9DBFD463C28B1B585033536D79BBF80D9133D907E7B081D4B4476193F0FB68BC1B41C2F543307E76F9B1A3D6D426EA7775127AC8309BCF45BE747D8A8BECED11E6A1D1B8F190AD6D6AC654E9DBAD4C9739C8D844A91A37167E68450CBB10F4AE8E2B69FA953EA5C991D3F1A3893F9086931BF1A089C7F22357D48E2FD571CD36F190B3983E19EAC80F129DBF58EDDC6B9A7984FCF04CC3B40DB87A8DAD7540D5D5DEC8CA393E45E4BCF433EA64E15E944291ABBC422AB3D06023CE578EFFADA22B64D994A0800F8E5017081D16CF51D0B928B659EF78CCC996F9CA877AEED9155EDF5DBCC258E604EE17DCB3F990F988329EA1DB1C3856539030692E52002CF30FD5802E025B99BFCD1112645B56C60AE638E74D21E598789DE6CB60B42EE49856CBADE6DD53F4C567A29FA05C7CFB245AA772D0E763F25DBFD8E9F16BB429A628E693D387B6D93C398DEA28C0963DF5C23C29F280218A039D64F8BA81C1DDA2882A842E3CB50395EDAA6EE26F5E993C63EEB84F6632774223362989B0ED5FF25A65663FD28B486865DCE0B0C27273F1A4C6562C5DD8C65C41CE308959A9D64596D08E7B25E013FBFE7CEAF3670DB29A213CCE9975A913CEF4236E64003087709CAD6181710E951926CA55297199A608AE545875CDC38FE383C14562B48DCA6602EA34055D983F38E61CCE531AD93F58EC162845F538CE4843871D3C4ADF05F35E297EA62EFCDD5EF9401BA042A235150A09D9474A3FB03AAA19E7E37A228D5F5B07414C3DA2AD2E5C75ECF04C112B90769E19960E975E8D1917B3BFDA84FDC6D2326FB8A3B00F95D9C52650111572BEC21B12127CA570D8A98AB977EBD8D79A59375EE14F64B5B04FD969FEB03D0AF73489E3BAEFE7C7BC8DC7E85483EE62F02398580F83B96DD84477B9C48F0BB39F5406A37036D6F36E2B1B6B53FE6FF61C327B29D4E05DD2B81174C60B59C79CB1976BC06E7AC34DF3E38F7D2C1C0E3151B7147AB831774770143B927B5FEC5DF776C1D72DB6BC9981D65867713CF297C8B0F1E98D0E16F0CC227A39E47E50BA0116156D5B5467536604BE05CC2EF40ABCE852F15DFA2CACF86A789E5B7B0E5BB4B777CD7CC9F654779B102F78B5AA4B94C3B4FDE55FA7F7BF54AC225E1F26165B65F16D0321669FD9F6E47FCA1DD347096DF5DDA86466A57C5B068D9C67B7320366EA19C8993FF90BD8FB0693FBA370E66D2B203B997011B0D15B94E28BAA2EBF01774F7AE78F84EDBDAD9F65A450427A4774C60CC89A020B37DA21C791DAC8F7A7457E30D08B01375160039C301B6051A965E8A7CCA2AEF93BD52F82C020BECE90A129024EFEA4B2FA21270F8EB5ED6AAAE55929AAC599A577972957660CC47AC4E3CE772BBF10052DE7EDB1B8A44941F884C9F8BE13174669945629F46DE2467444F3106A73FA279CF02A800A047E20BD4D820B389C3BB6A868A5384CF5724C204CEFB1A6A1BEB9723E36DDDDD9C707C8F63E8BC26683CC8B43C7DFDAA408AC4DD2BA9AECBC3B6DDAEDCE094AAB58FF732B196638D8B8EFC428BBA9615793C4DD9F00F90D62C676D127A0E18C14C6EE9C990510B054ADB4B4170AC7127F93175C1EB22512"
# pk = "6C8414380856CB52D79C4B29139FB1839B8606F5948B9D72A956DCF10116DA9E2D79770186FC74D942C0F4A3B595FF6C19804B49901C6AD5FAF71601C2B600315E1F40C2054767B00925DF3AA490E8C76F05FBFB74911075E6518C5F1D91B8A0E5B59830D3DF3994760411EBB911ED4CC2C160E3849A93762DFCA7B9812BC7AEB2DDB2767BEF36505605AE069260BCC8DC4787C428CB3C076EF2A6B93561D8943F45CABE8F0553FF2EA1AC95C1CE21593A175459D7DF12C4070ADB0EEE55B4ABAE59BE69C3FF0DE5A9B027FC7D8E6E057B7152EE6AB480D105D30B0F5051B60C7901C525C4635FE668CC00E9D3097DB99D66323715CE4F0B79B426B4545E09F4DE39323DD14CCB0D17108CD46DEC6138CDFA2872C1C4C8AEAD5C8CE04157E553A37558C2346A06194CB50B4981BF4D090CE4E860126A8254A4D4C084C3E2020BC0753521049B0FD88997E027AC51E75CF1350C3F303A0ECE426487153DAF1FAAD6808B9D9907DA9F35185BD3BE8D9CEBE916CED1FA2928D885A9CBA88149703F5E4772E48523125DDD026E714C49F4FB4E544BBF617A40B00B68DF8F155F5880D411877E25B42B2448B36BEC2F1F8F9A770C545150A0278E9B724500AEAAEA471C11CFF04E30EAB2F473BC048E32CD31AEF21579B699225BF9E1B6700C57E509FCA1F236294A5974DAA15FBCAD62D4BDDC4532B2614144DBE28807368C281A770EA22B1E5A3FA5BA14926DC55A54F84A2A77C5A70841F07BC1DEEF7403B247AB42B84ADF141E030C98468424DAAEB99D2577F950C2373CCA1E2DC2761B8EDD6D08FF79E528880FFB51C36ED420AC5D50F2582AA664E54EA5F4189EA0176DAA6122F6235A70B15CEB4DDD65D3BE6EBF3DC43189EE0A2E3105638F23873695280F1B74274352D60A48E5D3DD02FB7A5ED83FE27A698251421C8E9C98806102396E537390ACFD8C1D0B4F99B702A9EA659878583D92758941B30ECE507C104B2CE487679ECF68B4D8B980698ACF6AA6A57E8ED6AF3FF18D2668950428B57D182F73BB49B9B038CCC82D561278A386D56645EC3FAFFB4125E0E7F36B48B14B452547A0B481AA6B334229249153E42EDF7E49DD6E7636BFC615A23A401EFD4034C81B4DCEF027D344DDCCE0A71618EB5910CEC62228819385033E8D0ABD493D983E4FC087D72B455E4DB63A2F82CEFF65C1E628EAE630596DEC27FB98B84DBFDCDFAB40E472244914AFF179326D542D401A3CBB86E5FF8351EFE53A73C51ABB63FF553E7D7957EF89135E0F5BB1BD0C24F9E45E3236413C60E1396A47567C9439510F00D4A43C149A5CCC04F3D47E67A8E294A461A5F693DB0CAE22CFAC61E853477D339A4E45F7B17C3C116D56F3A068FC5ADFEF38FF85332BD5153C4D8FB8F148F117659C2EA94DB42AA0B0BEBB475A110412F3CD3349FC1AD041B7D5304A8593144EFA3A361D1B0C7613B82C086EA7126E43C616CEE8F1444E9956E87F5CAB95C7C7FB1758EC7D97019E5BA93543EF3BAC1A174299CA48BF7859DBFBDFF243B114F6BF423CE98B4D4D091DA44F3274D573FDC904BD885E35C9152A65354888F11ED4F3D63F26A7BE2F5726EADAF48586592BBDF6CEE246769E0EDA2A80771FED347D67AFEEC68B89463FA0496DBC15C89E8D569983D1D674733F2BF9DF4A980EA8C5E3AF15560A0E28D672B580AB6552ED76AACB5F80260B9703769D33F4138ABC10BF5B0582DCC62DBE58C890F51B4100127734FB7DB7447A720AAE009D00BE8C610792C64F131F2D72115C7E058E48B9DE64F55B4D610C36D112716A31A3DFE26699E9C2ABA05658CEF1B2B0867CF8D5233DB74FA8DC3AD145F5D28574360A85E3B0B10AC0A6467A7B05984628ECA10463F348A3111E00578D3CE5480F5375A1EE23EE82087BAC41233A14AAA724734B1874A4ACE1133706258F5FEA3A0C1609E30C7FD210DA0C4FDE9162DF66FBAF792FA2AEAA512F0FF7837B9CC02EE9BD95539F001BBD60DD8B42D616B2CA95F3835F5E47D43B1434C4563FD81C15BEFA202CF3D9540873F684AFE19AB5C01FA92E95A8CD6F360730856E59C9C6AB770D6575962AF75878572A2A26413D01AB318C100DFC34DC1DEFA5927C4B459925D73E1EB91470E37A58455C22A961FD53F7D99026FF884BF4A2579F706335EFB6FB2250D52AE561898BA1606E51E96D37C9ED3EC6CFCB33BFBE9C3143FD3B6B334D5F61922B369AFBB31C3E6E9B5F3AEBF95CB708346FECF7159CAD94A93D8CD4B8C4894192DFE53EA436FBF3AF4E864E8C3991EA020A811F0AF50B4257436A3FF522BE7367391D0F950BA6452FBFD8FD8728F40BD2FCB894529985B432DFEF6230EB4DEE737A8D10A3BCDFB763E0869B225C1A8D0E1FBF2D161C2C65D6DFB958E982D11777ACBEAD8DFB6B1F5EB21EA942F7C40DC20D2E4EB3E729B4E29F7501DA34234561F6288812D612D41DFA83C5B8D90FF38BA548201B575B5293AD78120D91CEC059CAE2E76A9AB43EF1281E2BEF3E348D28F21947C88848960459489775176F8E40EE06427953687FB63E470F7D59FB60DF569F8A11E28E0937162C46AFC7D2210A885FFA21B3DBF5354B2941F4ED5D50790890840CC3B973D2C3D02602B29BACCB6CE17CEDB97B085A2AB310572BA7371D1F8120FFE37D0B0FCA35AFC5B562AA8499715A299CE059CCE3B0D11CEF0D9238961AD4BE11E9A6D1A4692177C8B0C53F11A8ED2650212E7A2F80EBFF6DCFE4672103658434D0327ADDCD66BCB6"
pk = hex_to_bytes(pk)

M = "14426334940960773BFF65F08D1DE489C4C3ED36"
# M = "DB8494BA19C4118FB15D0ACF4254FD37483FCF4748FD1844F717CE6F69589E61772CFEFA7F9758653409D4EE5A264B834E60D6BB96499EBEB2B06B0BA874BF31E641394CFAA6A2D30DDB8F045876208D2F51DE15E205E8C91B87ECEB05FF3183271B2649665DD3CC49BFDB998D539DA809305516BBBE9C906021191C5223E525A8FC3616A1765EC3F9C5DB53CC337E039F186ACFEA91148EE2A79CCA3689EDB62AAF28B5D752FDE265EE5280B519726C1CA9803295C674B7EFAFA4D61B306A79E3F6E7A887C2FB535B3B0FB3D9EBC87603EAFEF170C1F1D28E99BB"
M = hex_to_bytes(M)

signature = "13E899EEDCCC0FBA629144E4AC067906B5326B8F9A6CCBABE1444ADD4645160D2257828710D1EE106021B5641E78815575D4F095D015D8465C92D2DDF4ABDFBEB11EE5E070E6DA52E548DC04FDEF5472E7E5F18210AACBA04F4F18AE6686B9AF9657E38E3B9BDDB4AA84E67B4D8192D003873DD3EEE74700FBD81E381C2198B7CCC137C171B22F9353419C48C14B8D630F996340275F6E604B95C435208AED2BCA1B419F8363F0950E240D6F9EAB118E4BD3DA0EC3A2BE26A8A09857713C36DD69C34EDD2C619E88267071CF9EE5A60CA3142DF163F01D8D796AC850CFF3666078B318FB5BD17360C876C9C90D8A7F412C8A31616BE7A3745871548486715C94263A17B36CA49925450C578AD9D4B1C20043F45E8431994FA6D26A141BAD9E496E009E914616CA570C09F638D062BEC687333AC7283834537EFB6042F37D83F7295DEA30D50090B6384C1729EF17A0D58750C0037514E5E1227853BC5AA31E95BEEC37B1518269262EA35ADA4FDA77627EEDDAAF57971BA36D467B19A90B991CD255DB79B0154886523031D6C5B1AE8FCF9A4310BBC8197484B2923BFE0B1215A1C4D8C68390898AD53E3369B7053FB18B0D874070902A5D3B3D91D81D4DF1087EF7DC0584EBDC63D7BA3C0D31F86DA6C0FD08115C53F6AEFEC0829A68D2A3442EEE4736702D66810D62308A8CC82AA62182F598F44E253711B5D60788BD0D690EF98F9AD593E03CEF38B9C977983F6911BA1AB9F735E928CDA38C03E6AD8362F460AE4CD0F46E00EEEC74B6123498AB31E7A79D334D72A7A7EEF3B551E78D31BC2CAFFB139CACA4D79C8BBD52BD78F4906509BE42E7763AE6ACB898285EC9323E68676A8CC74A58C8DA8BE911ED6F513B6608707310FB45CBD97D5FF0D2ABA36FCEF73D46CB7F01C2CFE38E68E84F4A301916D2F510D82B4969BE7A0E9CC60EFF5C0A8717B822838C77AF4206B12545089BB2DD6A3FF012C86415BBA04FD7D4EC707AF3B17F25574766F1E92738E06210F48A5EF2550EBDF85A5CA34497CF1D4D3A758648EC41172443835E5091BE8F047823D9620C2AD51C9611AAEE39B21E6D6AEC870C8915E266476A50EECA599622F7091A34C23F14B40429D95E3EF98FED3E749437F04BB4A337522E6809FC104503E253B41C4F0301AF467F74D33125FA83EF712445A171FA40EBF4E6553E454AFE2568021D2B2A198DEC9BF720F9D72F81520BE87466AF70D00E0E860FF9ABD03978C3E429B5AA17B97F9AE93448853D6EFD168A30C6CBE8DE2D288D9A24EA5D2A5823332B84FD2CE793A22BEC439848D4E60F3BB9C75D7EB0871E803D61B07E749ED76072B27C87B69D6C014261F647AFA88C4F1EC55A75A50FB4C79D2C94C0503DB20DFDF71F628874188CDD7385C03381DABB854D4AA9F47B66438C43FF53EF5E78AB450B450191278AF6E26A7B5E6461F577F9852F81C90203C713F5B1F6C3EF558C9032516D8D62FD5E24E4F0F50718F56B5A59A009D5938DAD5591F61F4C659A760526EF41202FA7E5F6C7D5E0B0C0C43B524B66712C5A7C53C84C50B83EB9C98D2FD084C9C5F21FEE7742E6EFC8CBBE5718B70C062D82E2F986F38DF1E71589DC7987243562A2319D7C00B26E531E93C38444618CE758734FDECFD0C6853728C61000784EDFFED7B33086E168D6CB63E3DACAF3552F885B478262DE5E1E63CE7A4C6695D1193835E45A67918C42D39BF880385330310F2C7BF91E6C3E29B781D09870C26D76BD8AE209C42BC7432DBB4C16526357A5634EECDE93C51DD4D6F0065B2EC57AD3B58266539597C8F42B55271D6F90E986F6828D959EE800DBEBCF48236BA3DE2527E0ECA4A3C2A34BBCDD6CBB3A9C96DC3BE110D3499466E2857FBA98123A6DBA9014877E24EADCCA40F8AE94B2FED236CBE5BCA9DFE0CBA9A0F86241331859F9D6C087B276DEC9356F1FEF69B359F9FB384A84022DECB70108DAC8E93BB6C300C0345FC640C006EAEBC15113812FB37DD96E2A06A463AFCE66C59F8D714AA1FF494F086FB9EADA184563CA9D8808B16C19A824AD857DDE51E508B7041235F300ED2C799C182305389576CF393CAEB0D3BA3E4EE4B577A3E37B275FD8051942AE9154E5BD7C35E0F895523A29B0E6B7AE20BE21DFF567EC8252FF5BD0AA145015E11C6A1B941BCC7601BF039442F200619658D9D04021FACE6BAB5D49D8D7BC9A66C2BA3FDC490DA55CB4670838EB2D07245BB1227B024A8A5338E9428EA55741D671A79D6A14D27D13FB59D0DAE5239E1BC42187BB78E038011DA0D1363FD0A78F86261EB026DE7E173A90FCC017DD78F5A32D3E29CE384576A95511B6B4E56EDD014B160799BD1977F5D79E399EAA8E2B75C5EB33566CD8B63F3F4E817E290A68ED1E9FDC6BFA18E3E57D057F22FAA2F60FB634567255165EF418D182FADDF7B89F7D301069C485D8E83489D493BE56EEDC43D48200FD1E2B0669071BBF33613928CA31910BF2EA328EA864139AEF791A9ABE52133249937DA88C48D4C01D108A4685AD29DF2ECD4183820128440EE5378D6BCA6198DE89A97BBB4448A28D823A5740607C6E69989893FA7E299A7453D8DCB34BDB7EFE95B0C72314EFCB493C09D77BD0119BACF2C22E7CCBCD597F6A09FEFEDFA0A7AC3C90BA7519F4016056D5FB412BA02D0D45CFF3A63D36EEE1E468E6EA2F673A7A02926BB318BA73EE1B2C137DEF4A39E803FF573553E9A5C6AA1A1721CA54387CB1DFB8FA7DA726B2AE7A05453B400A19E53252789DC3206324B2584B861F00A250F99FD9DC7D513DD7A65A04034EB33D2D56A496B36ABA0A3008E30FC13824885D9E6F681A7DB62DDDE3501BD40775E2E2CC09CC8E4E67027202A81170A57F4AC198C17FBF95BBCED36D4930B9508CFA3E8BF6E554E91BD7D6E53233BB91ADC815761A0435DECCE167264C2F4E34343D1E5AF7BCE60C9B7B7EE5DF729A0DDD4BE66F82FB5E2CC07B038576110EFDC7D55026BE755EC1F02E4762D6F1DADFF41CEE6352C44537E685A50A075463217B92F7330CD929CFE3ABB5FCAA262093558A0733B27D95027A769E7DBBC1F36E8410304B5D597368EC2A632D46E8C2F8EA2BC44FA76EF474EB96A364409B2363424B8F85004304AD617693BDC388C3FC2961BDB15A1F5B20EF95ED998496B2938182FFE3B927EA9A23F6428DD35C8611C839E316E9A5327CC9EA82509B215CC966BE1C7848EF392DA1C6F369A336253AA1152B6DCFDAA7CADD4D9A1D589F73D3EF0FBF03882FDEB944B5B6CFE26F6AB5123829558C4C736F0B687AC7068380FE7F61BE6B40E3F04D7B36820FD86329B3109D02EC6390EAFC8CA730562B68082424FDA98D0B64BC9734B40B63F7E37AF6890AF7C2D92F79EEA3CCEAC60A6F380692F802B1556A78FE5583FF20A9C6A7BFCC863A9E7B62014D1605DE894FB585E2D4F94115E029E5857E6A0A7389275F530D3D80CFAB1F225D38335D24679197D48A018A34187DE3BCCEDE94FF8EC534C02DA724D4598D669E85A9C60E45214FAA6544D6A47D1C4ED7409D55B1A7F115AE15443A1C310640D116238493EF3EE2879BB8461F7D68736470D4B573AE454993F532301E35CB9EEEDFFEA82FAC497753F75019F2B3B02C70B64A579531C326072ACF1BD0AAA09F0A978B78AB22BD6119F88DD2D572F8919D474F591DAE9FCE4753C985FB250425F26561FFA9443F2376689FEB48C4CE514604526A100AF33F0D4337D1604222C4D9F93A8E69E4CCD36669090C5DFB0E95494229FF9B20CCB1AC81B81A36D63A850DDB33334DAA5146BF36FE18801E3BEBD0E91B5E1CFE7A9826850AF4397D1B07D3B719E57BB832AF4234C0CD9FD40B882FCEDA937EF9A2DA24592BCB5D1BE83EC5F03DBDFBCB335D90D5C8A02EE53D508EB5DE4A961B958F751E5F89A1D28895A3DB7B62EF4AE16D28FB789B3203AD2463D6EAB83A6D20CEA1314AE02A3FF6F653154AE144238186214741C236148183BC39AEDF44DA97F731CE3DCB61A4CFE14F9E84AA05AB1C1B951D20155233FAFAF16CF1BD0BAFE199E65D563453BFE55D5F474AB10594D738A8C106288D69D07A1688601463F3BD2146819C83726D14C6A80839B8790B5716E772F6C24C2BEB7E2CF37B3F42ACDD473E8CCDBE484D6E07B073DECB174AC3B8BB2EF54E6DF9E02071FA600AE55967EB6F702F719159F0EB065CC46048E875E7CF4271AD2EDAF910829AF613BA89FC612A00FDAE537B093AE8CBE6B70D0301FA2E13A916381C92ECB451A36E3FA8B7373620C071A30534EDCB4A3F113117A502D6A72DE6C77BBBF6AE99859AACE64A928C374BD2C4652AC97EB744D29A70CEA9A19D7013497BCAB69631433F9ED1FE20F80B5983E1288BB6A2BE91543ED47928BB5E462D01E9C0B7FFFAC06C10F152F43C329E89DF8A79996A09798A367640BE9FB53DCE27BD0BAA9BF021BF10D2FCFE5B13FD7D84D1C1EBC0BCEC26D08780D13B9947672661E0FA5FAE6F315B6DE40168C2351DE31F41FF6C533226E1BCE3F8E216AF3BE64C693372A066B175F726CFCD642BAE980292C1CB65E01F0729640AB009CB98892D6CFE40033455DEE73033B6D5E19C599F8A400EB141527DF2BBDDEF50BBD5FB55AA5EFDB35D08569B0297E2481469F17B87B508936A9C5C11089AE9E4B0CAC5749393C803E47039F51B5CBD42A6C9E19EC3F63C2332E87768A960FA02186B7A2B029265091146730463DF8B375F24AA83BDD41D1304FC2FB52DA10F1FED652908CF8C528FB2625F393FC8C7B33FAD45BAD47D383D2C04CF32E807425F93D2350721B7B2F596648EB5E1386B43D12EFDDB8FE2436AEC278EE76875B523C5431D99485773D9ADBCD014DD87BC68FB82EE474B22A5433AF9F991FC34B25834DF13099A46F568AFD1155F321B9DA9E9C06347AB3C1F59F7EA0ED6CF47B3E9AF657AA7AE9BF8260B969DE4AD24D3A8CE95E577D0441305064E07B9A2C75C3C43801FCEB736FE3D271BE1F36BFFC8E43DB14A162476BAEA9D346B5211ABD00608B15AF3B5E63A00FF928D1EA1A18D75FA7C6C1B0FB6272E55C3FE7E4D4205E5CF0A1F8718304E14F2B4CC543D0437341A4A311601A92E92566B7DFB4264E870E1B3A875EDBC003A561970CF8A669F3D1B69288CC6E359CE28CA65F9DAE8CECA743C1C8D9FFB5508824A8361E33B431A2E9E9A997847D2E6E43C83F02262E2946DF7726D54E3E6C9CCDB6D3F136346C11E5942E7A1BF850C2E99B4FACE75FD40886933907CCDFC0DE117702031941D001E2A683C5578FD3354212CEAD969BF1C81239EECC774FD0B883D0EEE824B10B879CF707CB268474522061E927B1243244115C669E9EB272B60A644F519EFEC063408B658472E9161A1F744FD66169F0CAE36B42E2379CBE81E6E51A0F53415184EA006B2270B33E2CA364CDB33AAAE77FFD953DB39704D490CE9AC6F2DD1C7A18E617419A9AAFB37E7239B236A4B74CE63E4A0ADFF855DCD78F6458E760BFD1D2AB95E83C03B6FAE0CD3C5CEEEEE1C69515965A335FCF78E80AA739339542127170B2C3EE10B0EAA099AC7AD4CD76E7FE4C1164E62F4E5807DC0061F77E4A8A528D710375930CB755B28BFFD928CB07BB4A107CDCABB308A48650DA4E574D9BF5607F583DAC340D72093EFB12BBF93410F1EF5C9516C744D2315EC9E000A8DC5D17A7B6F0D079D784B6D90193F6E3EE7EA0EABFC6F68C52B37CBCE8218AFA3670A80BC17B95D7B40536226358F04ACD92A1BE15B26A4E5817E628BA679B3527203CD3632628EC83AA4F2186D2F005D5DFE6F7FDB4FEDAC9E89D666E303BB568306156C56F09534E25C619AB3B95018F4896BACAA4834F6D2D8FE14A938AA10E53054F0008444AC2EEA2538C1230E6A18C92B01D9147FDCEFC9C8DAC1D4ECC8CF1F962EFA1B8CD3C969000B7EBAC598DCA45EB40BCFB19851483851CF340F3E8C237A9EFF1C9F21E4975541C61A8FEF2AC6057F59DCB23A80E80610CD85DB203C35D24BC82B9CD78246F59FEBB24832D7CD664C995188E0281CD7867900DC0DF44D409080268B79E95682885F228770734FA53518EC80CE2306CE1448524EF0184303D450C76EA63B733EB0C8DC48BF12423AD23889CFCDD891E5950047240DC0C38AB2DBC165B81E631002EA6F74119E27F9F86073BF2DF710818676980C4CB6BD53F9A5721778B89F59C68C8935F5031C8A93367D717057FD4D5EFABEDE702CC645EFB6D7F44C860FFF7637AAD972248C844D15133920073891C3135D297868B7DA86F097D8FB39C13BA14C4F247516ABA4C5F8CE3818482C8FF60CCA51FDB2CEE96BC1138DC04A86F857727591AAE6F87C30059B3E81B68055B24EA2FA983686498BFC9D9E7D595079EB646E85B212CEDD21D0087E0F2AF663EB772A9847B1DF2197AF13626B897C24637AF5BFE81816A8C90D3048375B699497143E577185A70E115058A3A9112B2C4351B6CAD009282B4F7CB8BDFC285777D7DFE8F5000000000000000000000000000000000000000000000000000000000003060B11171F272E"
# signature = "F7789A45A3587330E7FCF70695F7F69688A2B8D0CE54F090214F109F56484F98C3AD1A53A5441C2CA72A3B3191BC046F46373045B9E540C73DFE91B61F0588D613593FCE1B00EEF1B227034C6FD3B18B3F221110FB345AA78631B8B59FBDFDCCDAE6A24D259D34AABAD218B3AE4E77186653B8563AA6120A0A531A4E913730DC914FE5E008BECE6869B02B07FDC16214540D316C43FA0C211B41AC7E52656729C773E4C4B88ED311886DD4D275417D70196644EED15FA315066003E309F832AF91262C949011FCB0AD2CCE65DD9EFF567EE29CC40A6FE0664E7D9F236568FC94295DBB34288233E8C511D28815EC721032296E1EDECA7F726A6EB0F76CC5828011C0E4013CC7EE4329B81ECC0D52ED1E491DD6D55C5265665ED8AD219B894F31C68C619AFCDB7358E5554C495B8B6E3325688FB8C1A25331D57BD348A27D390929BC46A1496AB35B46BA61B6B9D23CD06315FB72C24776016130ADB1CF2DC72959EA9CAD96AF5DA996126CDD85B134CC927A51FD23F84791A3FCDA077E15991748A0394F334EB8BC48A99AB9DFBB0F2AAD6FBE484961D3A4E8F8B21A6AC092B226D6E119FAD44D8E576FE96C6CDB6840EA614BAFC70786C519E1D5DC0F984443C8B1E54F8EE176D98B2C7027F57D7E3DE9B2A0A36911B8E47121DE0C07EBBA5D7B594EF244C68327EC6C6D1DD501F483FE9B9570597E70DF413E7AF03847F409ED61E2846E6C641E6A7FFA79DE6BFA373A0644B00BF41A034992A794DA17C88885239032C851764E3E4DBDE7F12A16C5A263E964C1E7FDD3CCE576DD6D56B18182848B7563645D4E42FF22742A996785169D7F503B48A7158B3CBD29935ED32049BEA1AD953EF707327B778BFDDDFC60511DA113A34F655712E4E59D6CCE404E94ABA61E8135388FC21C8E41344F324B01AC8C069F92575D34F88BCA22CB307E37070063320256B8BAD6EB7A81AFE9A254016E1C8A125089AAA3EDE84E5B6C2ECFAEFAA52B9F5709602C06AEA4A0384E9B09E5B88164B274EA3265FB5152397DFF5A3A0861E2BC12D2109289729747E83FDF243A1D17B98348379845A9E955E2D6F938DAA5918E2A14F97BA2BE501CCCAFD681910F4A4F06715CE84096F37A91DCCA2A8A4BE8DA7921DBF8D3F4EFB98C6B4F940ECEF832B549D068947C3DFB5809CB7B060A3A0EF3B21C0164501DDEA7C9E5E7897C6B1C46348B2C3E805F6F2287BA158CF925A7BA7F08254989C87D24979AD986AA97C51B01F45D4A1F24752991F04205EB551FD02D415F2DD1EFF142B0D70416C6D815EB91732B268FB20D0867442D71DEC057B286CD93811FF3F646EBD565D51D09A42D3ABAAC0F34CC817B18938ECCBB1FEF05BD3C2B494FA529ED4C634C9325A48173F20FFAC32DC101E6EE03B2FCBEC2468DBC8F76758C3215474F7EF24065F79060ACA3C8D5D74AF70F48301DDB30C05DB3EFA726CF88555901841282AA08F666A65351A6A24EED6BE211773107E185E1B488A2E491B6C141528462A86494B54FDCCECCB6AA21253686693AE798C9CE9E0BDDC6AE53D9B706DC4F4D81B9C73C461ECD7035C5172EFAE5602CAF88C64E79E5324030555DE211F89FD424C338C3883C83CA9405C2B5D1445F7C98C43ED3D2BECBE25F5F3F544CCC5B5AEAE47DDF3FB5649FF5D61EAA02EDEBC75CE478BA00426CAF474FA79E5B089EB1A882F15354592695952BA0A8EE91E649E3F2C382264DAA30F6A6D217F6129C1939B6DCACCDA5B637326E8A8361C3B56FCFFC485036865822B9BB87B43510BCDD55BC350DE7B2AE90A21E9E19978EDA10DF667614A44FE2A84D16BE043EA8773633EA6BADF65710052F341F65CBE928D3962A5A2FE64E46D6BFB8FD0D9978F0423CBD195F72F3CB19D7EFD9EBE33CD2F5709A57807DF944ECE568AACA4336422083B0697B6AA00586E4BF7DD673A3D596B8618AC3B4061750C6BE97CB53753D02395556075A26F140B93F577DAD505E1CF2B551A04C98C7F0901831B3CA61D75DA793AC72A44C7A07F7DBBAD60A55F49CBD79DEE4739FFD36778EBD08EBDB79EC07A16239C5B921599FEBFEA46DDF966AA4A01512E610943F5DC54B4C76B764B380BF2F84EDE32124912F54F7B6E207B7381F670F7AA0F3C3ED1015740384DD61A9765EE4696EACF82EA410691805CB688903535D7046100DCC2BA7D8302ACB0430D506CCC1C0DDEA7111A76F45B454E25CDDFB639B3D664C36D8843513A3FCAF9E6057E9BC068237FE2419A2D2D90B4A1FC2A71A146D2BD04364C79B8EBA8E3E88CE11E916E4A7528421328CF54FAAB2B19F44468781F8AB84B7DD972FF5615071430A4374DAFCAE1E6044AA98E985941BA6B9DB8C02F589603EEB8BE90A70EFC088D795E6DA1F1F2E6ECEDD031D8199E65912D434D09BFBE594406DC1150E99358CEA7FAD2E7C44C38B6E0CEEAB9BDE0DB97BCF5AC99410C9470E266B8BE45F6690831F4145E26379DB807C26DDF91E309D4F4A3E7ECAB7362F15D20EA433B7E70A7DDE7416CEA871498B2CE3F58D29D8628C531840F022DD3BD2F3809B1168D38E63C7F69308A31A2D4D5EEB974239B34A62BC85E4ECF90C336A0C37BD9E0EF4266B835AC8906A83CF0B35138A65E5D9A61FCC9B2D5A337B8ABEF88A7FB3C0945D7CAF35611AE0E44693A5BCE0A6E2FECAE9BDF4E356D6536B581A18F03A59164ED5447C7EC8BD997BE953DED932535B5F438A04319F5E0D8B0FEBC8DE8146658E52B9759C73935B120DC9B854F3C8F94EC9339057D7D7CD91F7E0B98D84EC7B2F92328D736018B03165A8745F8E77EB8029F9782670CBD86B4316C7BE4A880338BACFB015699BF30D3A4B05325435BA5FA3B9D2B2FE0B519C2CB246E53D1A343D661A66143C6F468C5538645CC26D4E2A8703EC9B10FC89BE6F859997708F31194F0DFEE92998B25E93B97070DE14409D5BA43DF88D15C2FBA97BDDE618CC3FC042F7748184BA9EC9CBA1B2006881D0514264198FB691C5C038E04950CF69099377FE66BA64E21952A44581719664F5D92397D22AA7032BF589AF8ACA48DF6D14EB43CEF0A9C8A8F9AD329525EF0AAA4F9E09C3513CF029F3DEFCBB4114FA0F668DB4722FCCD9C207B66F109ED95B454BB6195D59C4A678BA6F5A9B234121AD0516A1D4123D3826D92A61B35DEB295BAA2FE1B5EE25021DAEF857B5DF192E175E3A2A0D3F082F211CB5BDC236274F86C5DC74C39BE97CCF5F5794EB64EC645545210FC667D1E0740E66CBEDC20648CA1FA73414596BA08917A19A463AD3027C81836B8F4F02B99FC5083F06F34BD2309C2342AD88A84FA96E207C0108F6825414944F264ED6C4667C788D61A6BC2C456AF66C2F769E16901706912CC90D4B6C90DCA16CAC8FFED8397020E2975E24FF4C807C8AB731C81D36CA84C9121A8513E0C9D0F41BC68F88EACAA35599FAE3BBA6FCC6528D47E40C0764CF9C8383B3A44515E61D92CDAEC9CB9082B5A0C0379460D9179A7D9DF29E0B4B6A4118285215E87B6F118E9731E466FB3FEBD195E144FD2037D116627579AC55FED5E32585EC6638A0DFBE6ED6C5876CF8114C902AEFA363F4C9B72E7D5C852DCC1AF2B8852A9D0F995938865084CE5213B308A9CB37F681960D84EFE1DF5134A5915AE5878B10DA0FD4D9AC2AEF0C7E01C2E9E7C017E7BA740CEE1A899459BB75033EEAF3190D6779ED9EDD846A74E321528C03084A5D30874839718A53549B2EC6B2B730AA935CA6E1C4FD8BE0357D93F62174EEEDF8DAB7755B46657E59D7AA00B9F2F85E4C0F77FA11A5D69A23B1EF3A09F219D83B1F391F841318EEF35A326367BFA2B15FD714032092B9D02BF613AFF7696FADF1DE2C817077CB7C996776D69EC241A24254DA2D13987691EAC7EBA8CD8DCFB3947B1D99EDF962D215B318BB5F9AA04D1C82626A4173D02D410C586BCA4E51CA4F3E151B54F17A6BC9677609BBAF6C3038A67CADA66B4FDFB51029E07807D705969D96C9ABFB7162E45810A1DC4B56DA1477ED900A89CCAC298E17884269C39E8D7AB966F33DDADBE56A384CA20A7B1899EC18E2AE547000B904E34E46801D8574DB008417BCFDD1A74DC018E507B76B0FA08626235B1CE24BCFC320FAE3551C1C929B94C7C4965341829D8A1347D6A7385803B08BCDA84A27EA5E49CA1E6006EA232A53EE417EC881D3328A156382A6B293894DDF9B369CDE6B2FF59CB6A564E21C9279ECA0311F5D80CE39B98BF90DB327F74D3F762D117DF5F9132084FFB555A5D147221AF863ABF78715B72194529A0E334D4A191D42A99BEA52ADA2C7CC4A9774D5CB28D4ED82B61F94E89F60F0C8EA52DC079D4658BF8C856D6152D92251948B3BA014D8BAF3DCD36BC71F8E5B2CE6F535B7B9AE13DA4A1EAFFC253BE43A9F608EACE733CFCE52EA5CDA8359DB53FF3AF2CEFE8779BCC53C24A4B18D5E0D781BECF75B5477473A2024AD56C54A7F990EF6B1DFAC501088509D3A37F1C8D5C26487E420B7F4358E9269761FF1FA3AFCBECAEB68F5DDDE3AA8FD078CC4224CEA67132D7EBF5D232E43BADD218C0B4DBE1E16529866B9AB935885ACB415FBB1EEE69408A521B462EC59CD0D3C5496D985AEB0CE374F6772A4E6393A4EF007438090A8A9E52D2F55666D70F0000000000000000000000000000000000000000000000004080E121920"
signature = hex_to_bytes(signature)

a = Ver(pk,M,signature)

# print(a)

# test = "6306E6ADBAAF5509B5C86CED5FAF3F5D168FB8BFD7C4704E751F7D7AEC3ECF2D988D9A64516854341789E6D53E8CB9C713E68B25F35C2BB99B34208CE29D1F43"
# print(len(hex_to_bytes(test)))